### 1.简介


| OSI网络模型 | TCP/IP模型 | 对应的网络协议                  |
|---------|----------|--------------------------|
| 应用层     | 应用层      | HTTP、FTP、SMTP、DNS、TELNET |
| 表示层     | -        |                          |
| 会话层     | -        |                          |
| 传输层     | 传输层      | TCP, UDP                 |
| 网络层     | 网络层      | IP                       |
| 数据链路层   | 网络接口层    | Ethernet                 |
| 物理层     | -        |                          |

以上表格就是我们网络协议分层，TCP是传输层的一种协议，而HTTP是应用层的协议


### 2.TCP keepalive

在通讯中，如果双方长时间没有通讯，那如何知道对方还活着，以及如何得知这个Tcp链接是健康的且具有通讯能力呢？

Tcp的保活机制就是通过keepalive解决的。保活机制默认是关闭的，tcp链接的任何一方都可以打开此功能，主要是通过如下三个参数进行控制的

**tcp_keepalive_time**

保活时间，如果在一段保活时间内此链接都不活跃，开启保活功能的一端会向另一端发送一个保活的探测报文。如果对端正常存活且健康，对端必能能收到报文并进行相应。此时，发送端就能接收到相应报文证明TCP链接是健康的，就会重置计时器

**tcp_keepalive_intvl**

探测时间间隔，如果因为网络问题或者其他原因，导致发送端无法接收到响应，那么在一定的间隔后，会继续发送探测报文

**tcp_keepalive_probes**

探测循环次数上限，如果一直没有得到相应，发送方会一直发送，直到得到响应或者请求次数达到了上限位置，这个时候就会认为对端不可达，TCP链接已经失效，就会将连接中断

上面提到的三个参数，可以在linux的/proc/sys/net/ipv4/路径下找到，或通过sysctl -a | grep keepalive命令查询到，时间单位为秒


### 3.Http keep-alive


Http协议是运行在Tcp基础上的一种无状态应用层协议。他的特点就是，客户端的每一次请求都要和服务端建立Tcp通讯，建立以后断开连接，下次有请求的时候，继续建立连接

在早起的http1.0中，默认就是上述的这种方式，但是导致的问题就是创建连接和销毁连接性能损耗比较大

目前http1.1中引入了keepalive的机制，http1.0默认是关闭的，http1.1默认是开启的，即在Http请求头中设置"connection:keep-alive"进行开启，以及"connect:close"进行关闭

keep-alive机制：开启连接后，在一次http请求中，服务端相应后，不是直接拆除连接，而是维持一段时间，如果这段时间内客户端没有再次请求，则把连接断开。如果再时间内有请求进入，那么就会重置断开连接的计时器，这样的话就避免了链接的反复创建和拆除



