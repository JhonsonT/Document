### 1.CAP原理

一个分布式系统不可能同时满足CAP这三个要求，最多只能同时满足其中两个

C:consistence 一致性，多个副本之间能够保持一致的特性

A:availablity 可用性，指系统提供的服务必须一直处于可用状态，每次请求都能获取到非错的请求，但是不保证获取的数据为最新数据

P:Network partitioning 分区容错性，分布式系统再遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络都发生了故障

### 2.BASE理论

BASE是 Basically Avaible（基本可用）、Soft state(软状态)、Eventually consisitent(最终一致性)的三个短语的缩写，即无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性

#### 基本可用

允许出现响应时间或功能损失

#### 软状态

允许系统的数据存在中间状态、并认为改状态不影响系统的整体可用性、几允许系统在多个不通的节点的数据副本存在数据延时

#### 最终一致性

系统能够保证在没有其他新的更新操作的情况下，数据最终定一定能够达到一致的状态，因此所有的客户端对系统的数据访问最终能都能够获取到最新的值

### 3.分布式一致性协议

#### 2pc 两阶段提交协议

在分布式系统中，会有多个机器节点，因此需要一个协调者，而各个节点是参与者，协调者负责统一调用所有的分布式节点的执行逻辑，被调度的节点就是参与者

##### 协调流程

阶段一，询问参与者是否可以进行提交

协调者向参与者询问是否准备好了执行事物，并开始等待参与者的响应

参与者执行事务操作，并将undo和redo信息记录日志

如果参与者执行成功，则反馈消息到协调者为yes，表示事务执行成功，否则反馈no

阶段二，执行事务提交、回滚事务

如果阶段一中都成功并返回yes，则执行事务提交
如果接收到一个no，则事务回滚

提交流程：
发送事务提交请求，参与者commit，并完成提交以后释放整个事务执行期间占到事务资源，参与者在完成事务提交之后，向协调者发送ACK信息，收到所有参与者的ACK信息，完成事务。


回滚流程:
发送回滚请求，参与者进行rollback，完成后发送Ack信息，收到所有的ack信息后，完成事务

优点：
原理简单、实现方便

缺点：
同步阻塞、单点问题、数据不一致、过于保守


#### 3pc 三阶段提交协议

3pc中在参与者和协调者中都引入了超时机制、并把两阶段提交的第一个阶段拆分为了两个：询问然后再锁资源，最后真正提交

阶段一：CanCommit，协调者向所有的参与者发送一个包含实务内容的can commit请求，询问是否你可以执行事物的提交操作，然后参与者进行回馈yes或者no

阶段二:PreCommit，协调者收到后，执行事务预提交或中断事务。
协调者发送preCommit请求，进入prepared状态，参与者收到请求进行事物提交，并执行事务操作，对应2pc的执行事务，记录undo和redo。个参与者回馈执行结果，commit或者abor

阶段三：执行真正的提交，也会出现两种情况。
执行事务，协调者从预提交变为提交状态，参与进行提交操作，并释放资源，并发送ack到协调者，协调者进行处理，完成事务或者中断事务

优点：减少参与者的阻塞范围，第一阶段不阻塞，能够在单点故障后达成一致，3pc会根据协调者状态进行回滚或者提交

缺点：如果参与者收到precommit消息后，出现网络分区，那么参与者等待超时后，都会进行事务提交，就会出现事务不一致

### 4. 一致性算法

要解决的问题

1.数据不能存在单个节点上，否则会存在单点故障

2.多个节点需要保证具有相同的数据

3.一致性算法就是为了解决上面的问题

一致性算法就是数据保持一致，在分布式系统中，可以理解为多个节点的数据的值是一致的


#### paxos算法

1.Proposal提案，即分布式系统中的修改请求，可以表示为[提案编号N，提案内容value]

2.Client用户，类似于社会民众，负责提出建议

3.Propser议员，类似于基层人大代表，负责帮client上交提案

4.Acceptor投票者，类似于全国人大代表，负责为提案投票，不同意比以前接收过的提案编号小的提案，其他的提案都接受。例如A以前给N号提案表决过，那么再收到小于等于N号的提案时就直接拒绝了

5.Learner提案接受者，类似记录被通过提案饿记录员，负责记录提案

**basic paxos算法**

**可以参考如下地址: https://www.iteye.com/blog/iunknown-2246484**

1.propser准备一个n号提案

2.propser询问acceptor中的多数派是否接收过n号提案，如果都没有进入下一步，则本提案不被考虑

3.Acceptor开始表决，Acceptor无条件同意从未提交过的n号提案，达到多数派同意后，进入下一步

4.learner记录提案

流程图见~/document/分布式一致算法/BasicPaxos


缺点：

1.假设系统中有多个proposer，他们不断向acceptor发送提案，还没等到上一个提案达到半数派，下一个提案到达，就会导致acceptor放弃当前提案转向下一个提案，所有提案都别想通过，导致活锁

因此出现了multi paxos算法

**multo paxos算法**

根据上面到算法进行改造，系统中只存在一个proposer，称之为leader

1.若集群中没有leader，则在集群中选出一个节点并声明他为第M任leader

2.及群众到acceptor智能表决最新的leader发出的最新到提案

3.其他步骤和basic paxos相同

multi paxos中角色太多，对于计算机集群而言，可以将proposer、acceptor、learner三者身份集中到一个节点，此时只需要从集群中选出proposer，其他节点都是acceptor和learner，这就是接下来要讨论到raft算法


**raft算法**

1.Leader总统节点、负责发出提案

2.Follower追随节点，负责同意Leader发出到提案

3.Candidate候选人，负责争夺leader

步骤：raft算法将一致性问题分解为两个子问题，Leader选举和状态复制

**leader选举：**

每个follower都持有一个定时器，当定时器到了而集群中没有leader,follower就会把自己生命为candidate并参与leader选举，同时将消息发送给其他节点来争取他们到投票，若其他节点长时间没有相应cadidate将冲发送选举信息。集群中到其他节点将给candiate投票，获得多数派支持到candidate将会成为第M任Leader。在任的leader会不断发送心跳给其他节点证明自己还活着，其他节点收到心跳后就会清空自己的计时器并回复leader到心跳。当leader节点出现故障，没有接收到心跳到follower及诶单将准备成为candidate进入下一轮leader选举。若两个candiadate同时选举并获得相同票数，那么这两个节点将会随机推迟一段时间后再发出投票请求，这保证再次发送投票请求以后不冲突


**状态复制:**

leader负责接收来自client到提案请求，提案内容将包含再leader发出到下一次心跳中,follow接收到以后回复leader的心跳，leader接收到多数派follow的回复后确认提案并写入到自己到存储空间中并回复client，leader通知follow节点确认天并写到自己到存储空间，随后所有到数据都有相同到数据。如集群中出现了网络异常，导致了集群分裂，出现了多个leader，被分割到非多数派将无法达成共识，即脑裂。当集群再次连通时，将只听从最新任leader的指挥，就leader退化未follow，此时重新达成一致性状态


**ZAB算法**

1.ZAB算法是对multi paxos算法到改造，大部分和raft相同

和raft主要到区别：
1.对于leader到任期，raft叫做term，而ZAB叫做epoch
2.在状态复制到过程中，raft的心跳从leader向follow发送，而ZAB则相反

### 参考文档

1.[知乎问答](https://www.zhihu.com/question/440584986/answer/1691549932)
