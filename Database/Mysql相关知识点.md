参考链接: https://zhuanlan.zhihu.com/p/222958908


### 1.MyIsam和Innodb的区别

MyIsam引擎是5.1之前的默认引擎，支持全文搜索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于查询量大但是插入少的场景，而且MyIsam不支持外键，并且索引和数据是分开存储的

Innodb是基于聚餐索引创建的，和MyIsam相比它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起


### 2.Mysql的索引有哪些，聚簇和非聚簇索引的区别

索引按数据结构来说主要是包含了B+数和Hash索引

B+数是左小右大的存储结构，**节点只包含了id索引列，而叶子节点包含了索引列和数据，这种数据结构和索引在一起存储的索引方式叫做聚簇索引**，一张表中只能有一个聚簇索引。假设没有定义主键，Innodb会使用一个唯一非空的索引替代，如果没有的话，会隐式定义一个主键作为聚簇索引

![image](https://pic4.zhimg.com/80/v2-320a89f21fef9f624a962ab0984f98b3_1440w.jpg)

那非聚簇索引是什么样的结构呢，非聚簇索引[二级索引]保存的是**主键的id值**，这一点和**MyIsam保存的是数据地址**不同

![image](https://pic2.zhimg.com/80/v2-595b4d33bb2bcae9c5f965027dc3a329_1440w.jpg)

看一下InnoDb和MyIsam聚簇索引和非聚簇索引的区别

![image](https://pic1.zhimg.com/80/v2-456850b4603163bc88a79c20f9afb5bc_1440w.jpg)


### 3.覆盖索引和回表

覆盖索引是一次查询中，**如果一个索引包含了或者说覆盖了所有需要查询的字段的值**，我们就称之为覆盖索引，而不需要回表查询。而要确定一个索引是否是覆盖索引，我们只需要使用explain sql语句看Extra的结果是否是“Using Index”即可

回表查询就是通过数据库索引查询到数据所在行，然后再通过主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一颗索引树

### 4.锁的类型有哪些

Mysql的锁分为**共享锁**和**排他锁**，也叫做读锁和写锁

**读锁是共享的**，可以通过lock in share mode实现，**这个时候只能读不能写**

**写锁是排他的**，他会阻塞其他的**写锁和读锁**

从颗粒度上来说，可以分为**表锁**和**行锁**两种

表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter表结构的时候就会锁表

行锁又分为乐观锁和悲观锁，悲观锁通过for update实现，而乐观锁是通过版本号实现


### 5.事务的基本特征和隔离级别

事务的基础特征为ACID

A:原子性、C:一致性、I:隔离性、D:持久性

而隔离性有4个级别的隔离，分别是:

**read uncommit:读未提交**，可能**会读到其他事务未提交的数据**，这个也叫脏读

![image](https://pic4.zhimg.com/80/v2-32a03f131c50bd72988e4d04c7f02307_1440w.jpg)


**read commit:读已提交**，两次读取的结果不一致，也叫**不可重复读**，不可重复读解决了脏读的问题，只会读取已经提交的事务

![image](https://pic3.zhimg.com/80/v2-b9de6b0edec18bd56f274b8e8ae0ff1a_1440w.jpg)


**repeatable read:可重复读**，这个是mysql默认级别，就是每次读取的结果都一样，但是会产生幻读

例如事务A对一张表中的所有行数据进行修改，这个时候事务B对表里插入一行数据，这个时候A把事务提交，这个时候A查看数据发现有一行没修改，其实是B插入的，就好像幻觉一样，这也就是幻读。幻读都是读取了别的事务后的结果，不同于不可重读的区别是读取的不可重复读是一行数据，而幻读是一批数据

**serilizable:串行**，一般不会使用，他会给**每一行的读取的数据加锁**，会导致大量超时和锁竞争的问题


### 6.ACID靠什么保障的

A原子性由undo log保证，他记录了需要回滚的日志信息，事务回滚撤销已经执行成功的sql

C一致性是由代码层保证的

I隔离性是有MVCC保证的

D持久性是由内存和redo log保证的，mysql修改数据同时内存和redo log记录此操作，事务提交后时候通过redo log刷盘，宕机的时候通过redo log恢复

### 7.幻读和MVCC

了解幻读之前要了解MVCC，**MVCC也叫做多版本并发控制**，实际上就是保存了数据在**某个时间节点上的快照**

我们每行数据实际上隐藏了两个字段，**创建时间版本号和过期[删除]时间版本号**，每开始一个新的事务，版本号都会自动递增，事务开始时刻的系统版本号会作为事务的Id

即事务中读取的数据的版本号要小于等于当前事务的版本号，因此读入的数据就和当前并发的数据版本进行了隔离，不会相互影响

以下表为例:

id | name | create_version | delete_version
---|---|---|---
1 | "asheng" | 1 | 1
2 | "tom" | 2 | 2

这个时候假设A去执行查询，此时current_version=3

    select * from user where id <= 3

同时B去执行修改id=1的记录，current_version=4

    update user set name='1' where id = 1

如果这个时候C在删除id=2的数据，current_version=5

    delete user where id = 2

由于MVCC的原理是查找创建版本小于或者等于当前事务版本，删除版本为空或者大于当前事务版本，因此A的真实查询应该如下

    slelct * from user where id <= 3 and create_version <= 3 and (delete_version > 3 or delete_version is null)

所以A查询到的id=1的名字没有改变，且id=2的记录也能查询的到。这样做是为了保证事务读取数据实在事务开始之前就已经存在，要么事务自己插入或者修改的

那么这个时候理幻读就很好理解了。举个场景，用户注册的时候，我们先查询到数据不存在，然后插入

    1.A开始事务current_version=6查询记录是否存在，发现不存在
    2.B开始事务current_version=7去插入一条记录

这个时候，由于数据已经存在就会导致无法插入，这就是幻读

### 8.间隙锁

参考此文档：https://zhuanlan.zhihu.com/p/48269420

间隙锁是可重复读级别下才有的锁，结合MVCC和间隙锁可以结果幻读问题。幻读的问题存在是因为新增或者更新操作，这个时候如果进行了范围查询的时候（加锁查询），会出现不一致的情况，这个时候使用不挺的行锁已经无法满足需求，需要对一定范围的数据进行加锁，间隙锁就是解决这类问题。在可重复读的隔离级别下，数据库通过行锁和间隙锁共同组成（next-key lock）的来实现加锁规则

1.加锁的基本单位是Next-Key lock，它是前开后闭的原则

2.插入过程中访问的对象会增加锁

3.索引上的等值查询--给唯一索引加锁的时候，next-key lock会升级为行锁

4.索引上的等值查询--向右遍历时最后一个值不满足查询的时候，next-key lock退化为间隙锁

5.唯一索引上的查询范围会访问到不满足条件的第一个值为止


### 9.mysql的主从复制

1.master提交完事务，写入Binlog

2.slave连接到master，获取Binlog

3.master创建Dump线程，推送Binlog到slave

4.slave创建Io线程读取同步来的Binlog，记录到relay log中继日志中

5.slve再创建一个sql线程读取relay log事件并在slave中执行，完成同步

6.slave记录自己的binlog

![image](https://pic4.zhimg.com/80/v2-3f4098ddcf2173e707353e26ea68b657_1440w.jpg)

由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。

**全同步复制:**

主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响

**半同步复制:**

和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成


