### 数据库的事务的四大特征（acid）

#### 1. 原子性：

要不全部成功，要不全部失败

#### 2. 一致性：

是指事务必须使数据库从一个一致性状变换到另一个一致性状态，也就是说事务执行之前和之后都必须处于一致性状态

#### 3. 隔离性：

隔离性是当多个用户并发访问数据库时，当操作同一张表的时候，别的事务不能干扰当前事务，多个并发事务要相互隔离

#### 4. 持久性：

一旦事务提交了，那么对数据库的数据改变就是永久的。

---

### 如果不考虑事务，会导致的问题

#### 1. 脏读：

当一个事务处理过程中读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中多次的修改没有提交，这时另一个事务来访问数据，就会导致数据不一致。
例如：a向b转账，然后又撤回。这个时候b在a刚转账完成后开始读取数据，发现已经转了100，然后b撤销了，这个时候的数据就是假的，实际中并没有转入

#### 2. 不可重复读：

不可重复读诗对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的值，这时由于查询间隔，被另一个事务修改并提交了
例如：a读取某个数据，然后事务b立马修改了这个数据并提交到了数据库，这个时候a再次读取该数据，发现了不同的结果
不可重复读和脏读的区别：脏读是某一事务读了未提交的数据，而不可重复读是读取了另一个事务提交的数据

#### 3. 幻读：

幻读是事务非独立执行时发生的一种现象。例如事务a对一张表中的所有行的某个数据做了修改（例如从a修改到b），这个时候事务b有对这个表中插入了一行数据，而这个时候把数据作为a提交到数据库，这个时候事务a用户如果查看刚刚修改的数据，发现还有一行没有修改，其实是事务b插入的，就好像产生幻觉一样，就是幻读
幻读和不可重复读都是读取了另一个事务提交后的结果，不同的是不可重复读是针对同一个数据，而幻读针对的是一批数据整体。即事务A，做整体更新操作，但是B插入一条新纪录，事务A却没法修改这个数据，导致幻读。

---

### mysql 的数据隔离级别

#### 1. serializable：
可避免脏读、不可重复读、幻读等问题

#### 2. repeatable read:
可避免脏读和不可重复读 [mysql默认]

#### 3. read committed:
避免脏读的问题

#### 4. read uncommitted:
什么情况都不能保障

---

### 设置隔离级别

#### 查看mysql隔离级别：

    select @@tx_isolation;

#### 在mysql设置事务隔离级别：

    set [global|session] transaction isolation level '隔离级别'
    set tx_isolation='隔离级别'

#### java代码设置隔离级别：

    Connection conn = Driver.getConnection()
    conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE)
